/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/algorithms.js":
/*!***************************!*\
  !*** ./src/algorithms.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   linearRegression: () => (/* binding */ linearRegression),\n/* harmony export */   logisticRegression: () => (/* binding */ logisticRegression),\n/* harmony export */   neuralNetwork: () => (/* binding */ neuralNetwork)\n/* harmony export */ });\n// Core learning algorithms\n/**\n * Ordinary least squares for y = a + b x.\n * @param {{hours:number, score:number}[]} dataset\n * @returns {{slope:number, intercept:number, error:number}}\n */\n\nfunction sigmoid(x) {\n  return 1 / (1 + Math.exp(-x));\n}\n\nfunction linearRegression(dataset) {\n  if (!Array.isArray(dataset) || dataset.length < 2) {\n    throw new Error('Linear regression needs at least two sessions with different hours.');\n  }\n\n  const n = dataset.length;\n  const sumX = dataset.reduce((acc, d) => acc + d.hours, 0);\n  const sumY = dataset.reduce((acc, d) => acc + d.score, 0);\n  const sumXY = dataset.reduce((acc, d) => acc + d.hours * d.score, 0);\n  const sumXX = dataset.reduce((acc, d) => acc + d.hours * d.hours, 0);\n\n  const denominator = n * sumXX - sumX * sumX;\n  if (Math.abs(denominator) < 1e-12) {\n    throw new Error('Provide varied hour values so the line has a slope.');\n  }\n\n  const slope = (n * sumXY - sumX * sumY) / denominator;\n  const intercept = (sumY - slope * sumX) / n;\n\n  const error = dataset.reduce((acc, d) => {\n    const prediction = intercept + slope * d.hours;\n    return acc + Math.abs(prediction - d.score);\n  }, 0) / n;\n\n  return { slope, intercept, error };\n}\n\n/**\n * Binary logistic regression with SGD.\n * @param {{features:number[], label:0|1}[]} dataset\n * @param {{learningRate?:number, epochs?:number}} [options]\n * @returns {{weights:number[], bias:number, accuracy:number}}\n */\nfunction logisticRegression(dataset, options = {}) {\n  if (!Array.isArray(dataset) || dataset.length === 0) {\n    throw new Error('Logistic regression needs at least one labeled apple.');\n  }\n\n  const learningRate = options.learningRate ?? 0.05;\n  const epochs = options.epochs ?? 2500;\n  let weights = [0, 0];\n  let bias = 0;\n\n  for (let epoch = 0; epoch < epochs; epoch += 1) {\n    let gradW = [0, 0];\n    let gradB = 0;\n\n    dataset.forEach(({ features, label }) => {\n      const linear = weights[0] * features[0] + weights[1] * features[1] + bias;\n      const prediction = sigmoid(linear);\n      const error = prediction - label;\n      gradW[0] += error * features[0];\n      gradW[1] += error * features[1];\n      gradB += error;\n    });\n\n    weights = weights.map((w, idx) => w - (learningRate / dataset.length) * gradW[idx]);\n    bias -= (learningRate / dataset.length) * gradB;\n  }\n\n  const accuracy = dataset.reduce((acc, { features, label }) => {\n    const prediction = sigmoid(weights[0] * features[0] + weights[1] * features[1] + bias);\n    const predictedClass = prediction >= 0.5 ? 1 : 0;\n    return acc + (predictedClass === label ? 1 : 0);\n  }, 0) / dataset.length;\n\n  return { weights, bias, accuracy };\n}\n\n/**\n * Tiny 2-2-1 neural network with sigmoid activations.\n * @param {{features:number[], label:0|1}[]} dataset\n * @param {{learningRate?:number, epochs?:number}} [options]\n * @returns {{predict:(features:number[])=>number, accuracy:number, epochs:number}}\n */\nfunction neuralNetwork(dataset, options = {}) {\n  if (!Array.isArray(dataset) || dataset.length === 0) {\n    throw new Error('The neural network needs some labeled surprises to learn from.');\n  }\n\n  const learningRate = options.learningRate ?? 0.5;\n  const epochs = options.epochs ?? 4000;\n\n  let W1 = [\n    [Math.random() - 0.5, Math.random() - 0.5],\n    [Math.random() - 0.5, Math.random() - 0.5],\n  ];\n  let b1 = [0, 0];\n  let W2 = [Math.random() - 0.5, Math.random() - 0.5];\n  let b2 = 0;\n\n  const sigmoidDerivative = (x) => {\n    const s = sigmoid(x);\n    return s * (1 - s);\n  };\n\n  for (let epoch = 0; epoch < epochs; epoch += 1) {\n    let gradW1 = [[0, 0], [0, 0]];\n    let gradB1 = [0, 0];\n    let gradW2 = [0, 0];\n    let gradB2 = 0;\n\n    dataset.forEach(({ features, label }) => {\n      const z1 = [\n        W1[0][0] * features[0] + W1[0][1] * features[1] + b1[0],\n        W1[1][0] * features[0] + W1[1][1] * features[1] + b1[1],\n      ];\n      const a1 = [sigmoid(z1[0]), sigmoid(z1[1])];\n      const z2 = W2[0] * a1[0] + W2[1] * a1[1] + b2;\n      const prediction = sigmoid(z2);\n\n      const error = prediction - label;\n      gradW2[0] += error * a1[0];\n      gradW2[1] += error * a1[1];\n      gradB2 += error;\n\n      const deltaHidden = [\n        error * W2[0] * sigmoidDerivative(z1[0]),\n        error * W2[1] * sigmoidDerivative(z1[1]),\n      ];\n\n      gradW1[0][0] += deltaHidden[0] * features[0];\n      gradW1[0][1] += deltaHidden[0] * features[1];\n      gradW1[1][0] += deltaHidden[1] * features[0];\n      gradW1[1][1] += deltaHidden[1] * features[1];\n\n      gradB1[0] += deltaHidden[0];\n      gradB1[1] += deltaHidden[1];\n    });\n\n    const scaleFactor = learningRate / dataset.length;\n    W1 = W1.map((row, i) => row.map((value, j) => value - scaleFactor * gradW1[i][j]));\n    b1 = b1.map((value, i) => value - scaleFactor * gradB1[i]);\n    W2 = W2.map((value, i) => value - scaleFactor * gradW2[i]);\n    b2 -= scaleFactor * gradB2;\n  }\n\n  const predict = (features) => {\n    const z1 = [\n      W1[0][0] * features[0] + W1[0][1] * features[1] + b1[0],\n      W1[1][0] * features[0] + W1[1][1] * features[1] + b1[1],\n    ];\n    const a1 = [sigmoid(z1[0]), sigmoid(z1[1])];\n    const z2 = W2[0] * a1[0] + W2[1] * a1[1] + b2;\n    return sigmoid(z2);\n  };\n\n  const accuracy = dataset.reduce((acc, { features, label }) => {\n    const prediction = predict(features) >= 0.5 ? 1 : 0;\n    return acc + (prediction === label ? 1 : 0);\n  }, 0) / dataset.length;\n\n  return { predict, accuracy, epochs };\n}\n\n\n//# sourceURL=webpack://mlalgo/./src/algorithms.js?");

/***/ }),

/***/ "./src/data.js":
/*!*********************!*\
  !*** ./src/data.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createJsonTrainer: () => (/* binding */ createJsonTrainer),\n/* harmony export */   extractNumber: () => (/* binding */ extractNumber),\n/* harmony export */   parseBinaryLabel: () => (/* binding */ parseBinaryLabel),\n/* harmony export */   parseLinearDataset: () => (/* binding */ parseLinearDataset),\n/* harmony export */   parseLogisticDataset: () => (/* binding */ parseLogisticDataset),\n/* harmony export */   parseNeuralDataset: () => (/* binding */ parseNeuralDataset),\n/* harmony export */   toNumber: () => (/* binding */ toNumber)\n/* harmony export */ });\n// Data parsing and training helper UI\n\n/** Convert inputs to numbers or NaN for invalid/empty strings. */\nfunction toNumber(value) {\n  const numeric = typeof value === 'string' && value.trim() === '' ? Number.NaN : Number(value);\n  if (Number.isFinite(numeric)) return numeric;\n  return Number.NaN;\n}\n\n/** Try keys in order and return the first finite numeric value. */\nfunction extractNumber(obj, keys) {\n  for (const key of keys) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const numeric = toNumber(obj[key]);\n      if (Number.isFinite(numeric)) return numeric;\n    }\n  }\n  return undefined;\n}\n\n/** Normalize various boolean-like inputs into 0/1 labels. */\nfunction parseBinaryLabel(value, description) {\n  if (typeof value === 'boolean') return value ? 1 : 0;\n  if (typeof value === 'number') {\n    if (value === 0 || value === 1) return value;\n  }\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (['1', 'yes', 'y', 'true', 'ready', 'special'].includes(normalized)) return 1;\n    if (['0', 'no', 'n', 'false', 'ordinary'].includes(normalized)) return 0;\n  }\n  throw new Error(`${description} should be either 0/1, yes/no, or true/false.`);\n}\n\n/** Parse linear-regression rows: [{hours, score}] */\nfunction parseLinearDataset(raw) {\n  if (!Array.isArray(raw)) {\n    throw new Error('Please provide a JSON array of tasting sessions.');\n  }\n  if (raw.length < 2) {\n    throw new Error('Add at least two sessions so the line can be estimated.');\n  }\n  return raw.map((entry, index) => {\n    if (entry == null || typeof entry !== 'object') {\n      throw new Error(`Entry ${index + 1} must be an object with \"hours\" and \"score\".`);\n    }\n    const hours = extractNumber(entry, ['hours', 'Hours']);\n    const score = extractNumber(entry, ['score', 'Score']);\n    if (hours === undefined || !Number.isFinite(hours)) {\n      throw new Error(`Entry ${index + 1} needs a numeric \"hours\" value.`);\n    }\n    if (score === undefined || !Number.isFinite(score)) {\n      throw new Error(`Entry ${index + 1} needs a numeric \"score\" value.`);\n    }\n    return { hours, score };\n  });\n}\n\n/** Parse logistic-regression rows with either features or named fields. */\nfunction parseLogisticDataset(raw) {\n  if (!Array.isArray(raw)) {\n    throw new Error('Provide a JSON array where each item represents an apple.');\n  }\n  if (raw.length === 0) {\n    throw new Error('Add at least one apple example to train the classifier.');\n  }\n  return raw.map((entry, index) => {\n    if (entry == null || typeof entry !== 'object') {\n      throw new Error(`Entry ${index + 1} must be an object with tasting clues.`);\n    }\n    let features;\n    if (Array.isArray(entry.features) && entry.features.length >= 2) {\n      const first = toNumber(entry.features[0]);\n      const second = toNumber(entry.features[1]);\n      if (Number.isFinite(first) && Number.isFinite(second)) features = [first, second];\n    }\n    if (!features) {\n      const crunchiness = extractNumber(entry, ['crunchiness', 'Crunchiness']);\n      const colorDepth = extractNumber(entry, ['color', 'Color', 'colorDepth', 'Color depth']);\n      if (Number.isFinite(crunchiness) && Number.isFinite(colorDepth)) features = [crunchiness, colorDepth];\n    }\n    if (!features) {\n      throw new Error(`Entry ${index + 1} needs either a \"features\" array or numeric \"crunchiness\" and \"color depth\" values.`);\n    }\n    const labelSource = entry.label ?? entry.ready ?? entry['Ready'] ?? entry['Ready for market?'];\n    if (labelSource === undefined) {\n      throw new Error(`Entry ${index + 1} needs a yes/no outcome (\"label\" or \"ready\").`);\n    }\n    const label = parseBinaryLabel(labelSource, `Entry ${index + 1} outcome`);\n    return { features, label };\n  });\n}\n\n/** Parse XOR-like dataset rows for neural-net demo. */\nfunction parseNeuralDataset(raw) {\n  if (!Array.isArray(raw)) {\n    throw new Error('Provide a JSON array describing the surprising flavor pairs.');\n  }\n  if (raw.length === 0) {\n    throw new Error('Add at least one flavor pair so the network has something to learn.');\n  }\n  return raw.map((entry, index) => {\n    if (entry == null || typeof entry !== 'object') {\n      throw new Error(`Entry ${index + 1} must be an object with \"features\" or taste fields.`);\n    }\n    let features;\n    if (Array.isArray(entry.features) && entry.features.length >= 2) {\n      const first = toNumber(entry.features[0]);\n      const second = toNumber(entry.features[1]);\n      if (Number.isFinite(first) && Number.isFinite(second)) features = [first, second];\n    }\n    if (!features) {\n      const flavor = extractNumber(entry, ['flavor', 'Flavor', 'flavorSurprise', 'Flavor surprise']);\n      const texture = extractNumber(entry, ['texture', 'Texture', 'textureSurprise', 'Texture surprise']);\n      if (Number.isFinite(flavor) && Number.isFinite(texture)) features = [flavor, texture];\n    }\n    if (!features) {\n      throw new Error(`Entry ${index + 1} needs a \"features\" array or flavor & texture numbers.`);\n    }\n    const labelSource = entry.label ?? entry.special ?? entry['Special'] ?? entry['Special batch?'];\n    if (labelSource === undefined) {\n      throw new Error(`Entry ${index + 1} needs a yes/no label (\"label\" or \"special\").`);\n    }\n    const label = parseBinaryLabel(labelSource, `Entry ${index + 1} label`);\n    return { features, label };\n  });\n}\n\n/** Build a small UI to paste JSON and trigger re-training. */\nfunction createJsonTrainer({ title, sample, onTrain }) {\n  const wrapper = document.createElement('div');\n  wrapper.style.marginTop = '24px';\n  wrapper.style.padding = '16px';\n  wrapper.style.border = '1px solid #cbd5f5';\n  wrapper.style.background = '#f8f9ff';\n  wrapper.style.borderRadius = '12px';\n\n  const heading = document.createElement('h3');\n  heading.textContent = title;\n  heading.style.marginTop = '0';\n  heading.style.marginBottom = '8px';\n  heading.style.fontSize = '1.05rem';\n  heading.style.color = '#4338ca';\n  wrapper.appendChild(heading);\n\n  const description = document.createElement('p');\n  description.textContent = 'Paste a JSON array of examples and press “Train on this data” to rerun the model on your own notes. All values should be numbers so the algorithms can learn properly.';\n  description.style.marginTop = '0';\n  description.style.fontSize = '0.9rem';\n  description.style.color = '#334155';\n  wrapper.appendChild(description);\n\n  const textarea = document.createElement('textarea');\n  textarea.value = JSON.stringify(sample, null, 2);\n  textarea.style.width = '100%';\n  textarea.style.minHeight = '160px';\n  textarea.style.fontFamily = '\"Fira Code\", Consolas, monospace';\n  textarea.style.fontSize = '0.85rem';\n  textarea.style.padding = '12px';\n  textarea.style.border = '1px solid #c7d2fe';\n  textarea.style.borderRadius = '8px';\n  textarea.style.boxSizing = 'border-box';\n  textarea.style.background = '#ffffff';\n  wrapper.appendChild(textarea);\n\n  const controls = document.createElement('div');\n  controls.style.display = 'flex';\n  controls.style.alignItems = 'center';\n  controls.style.gap = '12px';\n  controls.style.marginTop = '12px';\n  wrapper.appendChild(controls);\n\n  const button = document.createElement('button');\n  button.textContent = 'Train on this data';\n  button.style.padding = '10px 18px';\n  button.style.border = 'none';\n  button.style.borderRadius = '999px';\n  button.style.background = 'linear-gradient(90deg, #4c1d95, #2563eb)';\n  button.style.color = '#ffffff';\n  button.style.fontWeight = '600';\n  button.style.cursor = 'pointer';\n  button.style.boxShadow = '0 8px 16px rgba(79, 70, 229, 0.25)';\n  controls.appendChild(button);\n\n  const status = document.createElement('span');\n  status.style.fontSize = '0.85rem';\n  status.style.fontWeight = '500';\n  controls.appendChild(status);\n\n  const setStatus = (message, isError = false) => {\n    status.textContent = message;\n    status.style.color = isError ? '#dc2626' : '#047857';\n  };\n\n  button.addEventListener('click', () => {\n    try {\n      const parsed = JSON.parse(textarea.value);\n      const message = onTrain(parsed);\n      if (typeof message === 'string' && message.trim().length > 0) {\n        setStatus(message);\n      } else {\n        setStatus('Model updated successfully!');\n      }\n    } catch (error) {\n      setStatus(error.message ?? 'Something went wrong while parsing the data.', true);\n    }\n  });\n\n  return { wrapper, setStatus, textarea };\n}\n\n\n//# sourceURL=webpack://mlalgo/./src/data.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _algorithms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms */ \"./src/algorithms.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ \"./src/data.js\");\n/* harmony import */ var _visualization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visualization */ \"./src/visualization.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\n\n\n\n\n\nconst root = document.createElement('div');\nroot.id = 'app';\nroot.style.fontFamily = 'system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif';\nroot.style.maxWidth = '960px';\nroot.style.margin = '0 auto';\nroot.style.padding = '32px';\nroot.style.lineHeight = '1.6';\nroot.style.background = '#f9fbff';\nroot.style.color = '#1f2933';\n\ndocument.body.style.margin = '0';\ndocument.body.style.background = '#e5ecf5';\ndocument.body.appendChild(root);\n\ndocument.title = 'Machine Learning Mini Story';\n\nconst header = document.createElement('header');\nheader.innerHTML = `\n  <h1 style=\"margin-bottom: 0.2em\">A Tiny Machine Learning Journey</h1>\n  <p style=\"margin-top: 0\">Follow along as our orchard scientist, Ada, learns how data can guide better apple tasting!</p>\n`;\nroot.appendChild(header);\n\n// UI helpers now imported from ./ui\n\nfunction buildLinearRegressionSection() {\n  const defaultDataset = [\n    { hours: 1, score: 52 },\n    { hours: 2, score: 57 },\n    { hours: 3, score: 63 },\n    { hours: 4, score: 69 },\n    { hours: 5, score: 75 },\n    { hours: 6, score: 83 },\n  ];\n\n  const section = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createSection)(\n    'Step 1 – Linear Regression — drawing the first tasting line',\n    'Ada starts by scoring apples after different tasting sessions. She hopes a straight-line rule will explain how sweetness improves the more she trains her senses.'\n  );\n\n  const tableContainer = document.createElement('div');\n  const insight = document.createElement('p');\n  insight.style.marginTop = '8px';\n  const canvasContainer = document.createElement('div');\n  const summaryContainer = document.createElement('div');\n  summaryContainer.style.marginTop = '16px';\n\n  section.appendChild(tableContainer);\n  section.appendChild(insight);\n  section.appendChild(canvasContainer);\n  section.appendChild(summaryContainer);\n\n  const render = (dataset) => {\n    tableContainer.innerHTML = '';\n    const table = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createTable)(\n      ['Session hours', 'Sweetness score'],\n      dataset.map((d) => ({ Hours: (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.hours, 2), Score: (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.score, 2) }))\n    );\n    tableContainer.appendChild(table);\n\n    canvasContainer.innerHTML = '';\n    summaryContainer.innerHTML = '';\n\n    try {\n      const model = (0,_algorithms__WEBPACK_IMPORTED_MODULE_0__.linearRegression)(dataset);\n      insight.style.color = '#1f2933';\n      insight.innerHTML = `The line Ada finds is <code>sweetness = ${(0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(model.intercept)} + ${(0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(model.slope)} × hours</code>.<br>She now has a simple rule-of-thumb for planning practice time.`;\n      const canvas = (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.createCanvas)();\n      (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.drawLinearRegressionPlot)(canvas, dataset, model);\n      canvasContainer.appendChild(canvas);\n      summaryContainer.style.color = '#1f2933';\n      summaryContainer.appendChild((0,_ui__WEBPACK_IMPORTED_MODULE_3__.summarizeLinearRegression)(model));\n    } catch (error) {\n      insight.style.color = '#dc2626';\n      insight.textContent = error.message;\n      summaryContainer.style.color = '#dc2626';\n      summaryContainer.textContent = 'Adjust the data and try again.';\n      throw error;\n    }\n  };\n\n  const trainer = (0,_data__WEBPACK_IMPORTED_MODULE_1__.createJsonTrainer)({\n    title: 'Bring your own tasting sessions',\n    sample: defaultDataset,\n    onTrain: (raw) => {\n      const parsed = (0,_data__WEBPACK_IMPORTED_MODULE_1__.parseLinearDataset)(raw);\n      render(parsed);\n      return `Trained on ${parsed.length} sessions!`;\n    },\n  });\n\n  section.appendChild(trainer.wrapper);\n\n  try {\n    render(defaultDataset);\n  } catch (error) {\n    trainer.setStatus(error.message, true);\n  }\n  root.appendChild(section);\n}\n\nfunction buildLogisticRegressionSection() {\n  const defaultDataset = [\n    { features: [2, 2], label: 0 },\n    { features: [3, 3], label: 0 },\n    { features: [4, 2], label: 0 },\n    { features: [6, 5], label: 1 },\n    { features: [7, 6], label: 1 },\n    { features: [8, 5], label: 1 },\n    { features: [5, 7], label: 1 },\n    { features: [3, 6], label: 0 },\n  ];\n\n  const section = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createSection)(\n    'Step 2 – Logistic Regression — pass or fail the tasting?',\n    'Sweetness scores were useful, but the orchard team now needs a yes/no decision: which apples are ready for the market? Ada collects two clues per apple: crunchiness and color depth.'\n  );\n\n  const tableContainer = document.createElement('div');\n  const story = document.createElement('p');\n  story.innerHTML = 'Ada\\'s rule now predicts a probability between 0 and 1. Apples above <code>50%</code> probability are shipped. The decision boundary is the bright blue line — in 2D it looks straight, but it comes from the S-shaped logistic curve.';\n  const canvasContainer = document.createElement('div');\n  const summaryContainer = document.createElement('div');\n  summaryContainer.style.marginTop = '16px';\n\n  section.appendChild(tableContainer);\n  section.appendChild(story);\n  section.appendChild(canvasContainer);\n  section.appendChild(summaryContainer);\n\n  const render = (dataset) => {\n    tableContainer.innerHTML = '';\n    const table = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createTable)(\n      ['Crunchiness (1-10)', 'Color depth (1-10)', 'Ready for market?'],\n      dataset.map((d) => ({\n        Crunchiness: (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.features[0], 2),\n        'Color depth': (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.features[1], 2),\n        Ready: d.label ? 'Yes' : 'No',\n      }))\n    );\n    tableContainer.appendChild(table);\n\n    canvasContainer.innerHTML = '';\n    summaryContainer.innerHTML = '';\n    summaryContainer.style.color = '#1f2933';\n\n    try {\n      const model = (0,_algorithms__WEBPACK_IMPORTED_MODULE_0__.logisticRegression)(dataset, { learningRate: 0.1, epochs: 2500 });\n      const canvas = (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.createCanvas)();\n      (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.drawLogisticRegressionPlot)(canvas, dataset, model);\n      canvasContainer.appendChild(canvas);\n      summaryContainer.appendChild((0,_ui__WEBPACK_IMPORTED_MODULE_3__.summarizeLogisticRegression)(model));\n    } catch (error) {\n      summaryContainer.style.color = '#dc2626';\n      summaryContainer.textContent = error.message;\n      throw error;\n    }\n  };\n\n  const trainer = (0,_data__WEBPACK_IMPORTED_MODULE_1__.createJsonTrainer)({\n    title: 'Experiment with your own apples',\n    sample: defaultDataset,\n    onTrain: (raw) => {\n      const parsed = (0,_data__WEBPACK_IMPORTED_MODULE_1__.parseLogisticDataset)(raw);\n      render(parsed);\n      return `Re-trained on ${parsed.length} apples!`;\n    },\n  });\n\n  section.appendChild(trainer.wrapper);\n\n  try {\n    render(defaultDataset);\n  } catch (error) {\n    trainer.setStatus(error.message, true);\n  }\n  root.appendChild(section);\n}\n\nfunction buildNeuralNetworkSection() {\n  const defaultDataset = [\n    { features: [0, 0], label: 0 },\n    { features: [0, 1], label: 1 },\n    { features: [1, 0], label: 1 },\n    { features: [1, 1], label: 0 },\n  ];\n\n  const section = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createSection)(\n    'Step 3 – Neural Network — catching surprising flavor combos',\n    'The final tasting challenge is trickier. Some apples only shine when either texture or flavor is surprising, but not both at the same time. Simple lines cannot describe this either/or rule, so Ada builds a tiny neural network with a hidden layer to spot the pattern.'\n  );\n\n  const tableContainer = document.createElement('div');\n  const story = document.createElement('p');\n  story.textContent = 'Two hidden neurons combine to build the familiar S-shapes, but stacking them lets Ada draw bends and corners. The colored background shows the network\\'s confidence — orange for special batches, purple for ordinary ones.';\n  const canvasContainer = document.createElement('div');\n  const summaryContainer = document.createElement('div');\n  summaryContainer.style.marginTop = '16px';\n\n  section.appendChild(tableContainer);\n  section.appendChild(story);\n  section.appendChild(canvasContainer);\n  section.appendChild(summaryContainer);\n\n  const render = (dataset) => {\n    tableContainer.innerHTML = '';\n    const table = (0,_ui__WEBPACK_IMPORTED_MODULE_3__.createTable)(\n      ['Flavor surprise', 'Texture surprise', 'Special batch?'],\n      dataset.map((d) => ({\n        'Flavor surprise': (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.features[0], 2),\n        'Texture surprise': (0,_ui__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(d.features[1], 2),\n        'Special batch?': d.label ? 'Yes' : 'No',\n      }))\n    );\n    tableContainer.appendChild(table);\n\n    canvasContainer.innerHTML = '';\n    summaryContainer.innerHTML = '';\n    summaryContainer.style.color = '#1f2933';\n\n    try {\n      const model = (0,_algorithms__WEBPACK_IMPORTED_MODULE_0__.neuralNetwork)(dataset, { learningRate: 0.8, epochs: 6000 });\n      const canvas = (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.createCanvas)();\n      (0,_visualization__WEBPACK_IMPORTED_MODULE_2__.drawNeuralNetworkPlot)(canvas, dataset, model);\n      canvasContainer.appendChild(canvas);\n      summaryContainer.appendChild((0,_ui__WEBPACK_IMPORTED_MODULE_3__.summarizeNeuralNetwork)(model));\n    } catch (error) {\n      summaryContainer.style.color = '#dc2626';\n      summaryContainer.textContent = error.message;\n      throw error;\n    }\n  };\n\n  const trainer = (0,_data__WEBPACK_IMPORTED_MODULE_1__.createJsonTrainer)({\n    title: 'Invent new surprise combos',\n    sample: defaultDataset,\n    onTrain: (raw) => {\n      const parsed = (0,_data__WEBPACK_IMPORTED_MODULE_1__.parseNeuralDataset)(raw);\n      render(parsed);\n      return `Re-trained on ${parsed.length} flavor pairs!`;\n    },\n  });\n\n  section.appendChild(trainer.wrapper);\n\n  try {\n    render(defaultDataset);\n  } catch (error) {\n    trainer.setStatus(error.message, true);\n  }\n  root.appendChild(section);\n}\n\nbuildLinearRegressionSection();\n(0,_ui__WEBPACK_IMPORTED_MODULE_3__.addStoryDivider)(root);\nbuildLogisticRegressionSection();\n(0,_ui__WEBPACK_IMPORTED_MODULE_3__.addStoryDivider)(root);\nbuildNeuralNetworkSection();\n\n\n//# sourceURL=webpack://mlalgo/./src/index.js?");

/***/ }),

/***/ "./src/ui.js":
/*!*******************!*\
  !*** ./src/ui.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addStoryDivider: () => (/* binding */ addStoryDivider),\n/* harmony export */   createSection: () => (/* binding */ createSection),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   formatNumber: () => (/* binding */ formatNumber),\n/* harmony export */   summarizeLinearRegression: () => (/* binding */ summarizeLinearRegression),\n/* harmony export */   summarizeLogisticRegression: () => (/* binding */ summarizeLogisticRegression),\n/* harmony export */   summarizeNeuralNetwork: () => (/* binding */ summarizeNeuralNetwork)\n/* harmony export */ });\n/** UI helpers for DOM, summaries, and dividers */\n\n/**\n * Create a styled section with title and intro paragraph.\n * @param {string} title\n * @param {string} intro\n * @returns {HTMLElement}\n */\nfunction createSection(title, intro) {\n  const section = document.createElement('section');\n  section.style.marginTop = '32px';\n  section.style.padding = '24px';\n  section.style.background = '#ffffff';\n  section.style.borderRadius = '16px';\n  section.style.boxShadow = '0 12px 30px rgba(15, 23, 42, 0.08)';\n\n  const heading = document.createElement('h2');\n  heading.textContent = title;\n  heading.style.marginTop = '0';\n  section.appendChild(heading);\n\n  const introPara = document.createElement('p');\n  introPara.textContent = intro;\n  section.appendChild(introPara);\n\n  return section;\n}\n\n/**\n * Create a simple table from headers and row objects.\n * @param {string[]} headers\n * @param {Record<string, string|number>[]} rows\n * @returns {HTMLTableElement}\n */\nfunction createTable(headers, rows) {\n  const table = document.createElement('table');\n  table.style.width = '100%';\n  table.style.borderCollapse = 'collapse';\n  table.style.margin = '16px 0';\n\n  const thead = document.createElement('thead');\n  const headRow = document.createElement('tr');\n  headers.forEach((h) => {\n    const th = document.createElement('th');\n    th.textContent = h;\n    th.style.textAlign = 'left';\n    th.style.padding = '8px';\n    th.style.borderBottom = '2px solid #cbd2d9';\n    th.style.fontSize = '0.9rem';\n    th.style.color = '#52606d';\n    headRow.appendChild(th);\n  });\n  thead.appendChild(headRow);\n  table.appendChild(thead);\n\n  const tbody = document.createElement('tbody');\n  rows.forEach((row, idx) => {\n    const tr = document.createElement('tr');\n    Object.values(row).forEach((value) => {\n      const td = document.createElement('td');\n      td.textContent = value;\n      td.style.padding = '8px';\n      td.style.borderBottom = '1px solid #e4e7eb';\n      td.style.background = idx % 2 === 0 ? '#f8fafc' : '#ffffff';\n      td.style.fontSize = '0.9rem';\n      td.style.color = '#243b53';\n      tr.appendChild(td);\n    });\n    tbody.appendChild(tr);\n  });\n  table.appendChild(tbody);\n\n  return table;\n}\n\n/**\n * Format a number with fixed digits.\n * @param {number|string} value\n * @param {number} [digits=2]\n * @returns {string}\n */\nfunction formatNumber(value, digits = 2) {\n  return Number.parseFloat(value).toFixed(digits);\n}\n\n/**\n * Build summary list for linear regression.\n * @param {{slope:number, intercept:number, error:number}} model\n */\nfunction summarizeLinearRegression(model) {\n  const list = document.createElement('ul');\n  list.innerHTML = `\n    <li>Slope (how much sweetness rises per extra tasting hour): <strong>${formatNumber(model.slope)}</strong></li>\n    <li>Intercept (sweetness before tasting even starts): <strong>${formatNumber(model.intercept)}</strong></li>\n    <li>Average prediction error: <strong>${formatNumber(model.error)}</strong></li>\n  `;\n  return list;\n}\n\n/**\n * Build summary list for logistic regression.\n * @param {{weights:number[], bias:number, accuracy:number}} model\n */\nfunction summarizeLogisticRegression(model) {\n  const list = document.createElement('ul');\n  list.innerHTML = `\n    <li>Weights learned for crunchiness & color depth: <strong>${model.weights.map((w) => formatNumber(w)).join(', ')}</strong></li>\n    <li>Bias (baseline confidence): <strong>${formatNumber(model.bias)}</strong></li>\n    <li>Accuracy on the tasting notes: <strong>${formatNumber(model.accuracy * 100)}%</strong></li>\n  `;\n  return list;\n}\n\n/**\n * Build summary list for the tiny neural net.\n * @param {{epochs:number, accuracy:number}} model\n */\nfunction summarizeNeuralNetwork(model) {\n  const list = document.createElement('ul');\n  list.innerHTML = `\n    <li>Hidden taste detectors discovered: <strong>2 neurons</strong></li>\n    <li>Training epochs completed: <strong>${model.epochs}</strong></li>\n    <li>Accuracy on tricky surprises: <strong>${formatNumber(model.accuracy * 100)}%</strong></li>\n  `;\n  return list;\n}\n\n/**\n * Insert a decorative divider between story sections.\n * @param {HTMLElement} root\n */\nfunction addStoryDivider(root) {\n  const divider = document.createElement('div');\n  divider.style.height = '2px';\n  divider.style.margin = '48px 0 24px';\n  divider.style.background = 'linear-gradient(90deg, rgba(79, 70, 229, 0.25), rgba(14, 165, 233, 0.6))';\n  root.appendChild(divider);\n}\n\n\n\n//# sourceURL=webpack://mlalgo/./src/ui.js?");

/***/ }),

/***/ "./src/visualization.js":
/*!******************************!*\
  !*** ./src/visualization.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   drawAxes: () => (/* binding */ drawAxes),\n/* harmony export */   drawLinearRegressionPlot: () => (/* binding */ drawLinearRegressionPlot),\n/* harmony export */   drawLogisticRegressionPlot: () => (/* binding */ drawLogisticRegressionPlot),\n/* harmony export */   drawNeuralNetworkPlot: () => (/* binding */ drawNeuralNetworkPlot),\n/* harmony export */   getRange: () => (/* binding */ getRange),\n/* harmony export */   scale: () => (/* binding */ scale)\n/* harmony export */ });\n// Visualization helpers and drawing routines\n/** Create a canvas with consistent styling. */\nfunction createCanvas(width = 360, height = 260) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  canvas.style.borderRadius = '12px';\n  canvas.style.border = '1px solid #d9e2ec';\n  canvas.style.background = '#fefeff';\n  canvas.style.marginTop = '16px';\n  return canvas;\n}\n\n/** Compute min/max with padding for nicer axes. */\nfunction getRange(values) {\n  const min = Math.min(...values);\n  const max = Math.max(...values);\n  if (min === max) {\n    return { min: min - 1, max: max + 1 };\n  }\n  const padding = (max - min) * 0.1;\n  return { min: min - padding, max: max + padding };\n}\n\n/** Linear scale mapping from domain to range. */\nfunction scale(value, domain, range) {\n  const ratio = (value - domain.min) / (domain.max - domain.min);\n  return range.min + ratio * (range.max - range.min);\n}\n\n/** Draw X/Y axes with labels. */\nfunction drawAxes(ctx, width, height, margin, xLabel, yLabel) {\n  ctx.strokeStyle = '#9aa5b1';\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.moveTo(margin.left, height - margin.bottom);\n  ctx.lineTo(width - margin.right, height - margin.bottom);\n  ctx.moveTo(margin.left, height - margin.bottom);\n  ctx.lineTo(margin.left, margin.top);\n  ctx.stroke();\n\n  ctx.fillStyle = '#52606d';\n  ctx.font = '12px system-ui';\n  ctx.fillText(xLabel, width - margin.right - 40, height - margin.bottom + 24);\n  ctx.fillText(yLabel, margin.left - 30, margin.top + 12);\n}\n\n/** Scatter and fitted line for linear regression. */\nfunction drawLinearRegressionPlot(canvas, dataset, model) {\n  const ctx = canvas.getContext('2d');\n  const margin = { top: 16, right: 16, bottom: 32, left: 48 };\n  const plotWidth = canvas.width;\n  const plotHeight = canvas.height;\n\n  const xRange = getRange(dataset.map((d) => d.hours));\n  const yRange = getRange(dataset.map((d) => d.score));\n\n  drawAxes(ctx, plotWidth, plotHeight, margin, 'Hours tasted', 'Sweetness score');\n\n  dataset.forEach((point) => {\n    const x = scale(point.hours, xRange, { min: margin.left, max: plotWidth - margin.right });\n    const y = scale(point.score, yRange, { min: plotHeight - margin.bottom, max: margin.top });\n    ctx.fillStyle = '#1d4ed8';\n    ctx.beginPath();\n    ctx.arc(x, y, 5, 0, Math.PI * 2);\n    ctx.fill();\n  });\n\n  ctx.strokeStyle = '#ef4444';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  const xMin = xRange.min;\n  const xMax = xRange.max;\n  const yStart = model.intercept + model.slope * xMin;\n  const yEnd = model.intercept + model.slope * xMax;\n  const startX = scale(xMin, xRange, { min: margin.left, max: plotWidth - margin.right });\n  const endX = scale(xMax, xRange, { min: margin.left, max: plotWidth - margin.right });\n  const startY = scale(yStart, yRange, { min: plotHeight - margin.bottom, max: margin.top });\n  const endY = scale(yEnd, yRange, { min: plotHeight - margin.bottom, max: margin.top });\n  ctx.moveTo(startX, startY);\n  ctx.lineTo(endX, endY);\n  ctx.stroke();\n}\n\n/** Scatter and decision boundary for logistic regression. */\nfunction drawLogisticRegressionPlot(canvas, dataset, model) {\n  const ctx = canvas.getContext('2d');\n  const margin = { top: 16, right: 16, bottom: 32, left: 48 };\n  const plotWidth = canvas.width;\n  const plotHeight = canvas.height;\n\n  const xRange = getRange(dataset.map((d) => d.features[0]));\n  const yRange = getRange(dataset.map((d) => d.features[1]));\n\n  drawAxes(ctx, plotWidth, plotHeight, margin, 'Crunchiness', 'Color depth');\n\n  dataset.forEach((point) => {\n    const x = scale(point.features[0], xRange, { min: margin.left, max: plotWidth - margin.right });\n    const y = scale(point.features[1], yRange, { min: plotHeight - margin.bottom, max: margin.top });\n    ctx.fillStyle = point.label === 1 ? '#16a34a' : '#ef4444';\n    ctx.beginPath();\n    ctx.arc(x, y, 6, 0, Math.PI * 2);\n    ctx.fill();\n  });\n\n  const { weights, bias } = model;\n  const w1 = weights[0];\n  const w2 = weights[1];\n  if (Math.abs(w2) > 1e-6) {\n    const xStart = xRange.min;\n    const xEnd = xRange.max;\n    const yStart = (-bias - w1 * xStart) / w2;\n    const yEnd = (-bias - w1 * xEnd) / w2;\n    ctx.strokeStyle = '#0ea5e9';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(\n      scale(xStart, xRange, { min: margin.left, max: plotWidth - margin.right }),\n      scale(yStart, yRange, { min: plotHeight - margin.bottom, max: margin.top }),\n    );\n    ctx.lineTo(\n      scale(xEnd, xRange, { min: margin.left, max: plotWidth - margin.right }),\n      scale(yEnd, yRange, { min: plotHeight - margin.bottom, max: margin.top }),\n    );\n    ctx.stroke();\n  }\n}\n\n/** Confidence background and scatter for the tiny neural network. */\nfunction drawNeuralNetworkPlot(canvas, dataset, model) {\n  const ctx = canvas.getContext('2d');\n  const margin = { top: 16, right: 16, bottom: 32, left: 48 };\n  const plotWidth = canvas.width;\n  const plotHeight = canvas.height;\n\n  const xValues = dataset.map((d) => d.features[0]);\n  const yValues = dataset.map((d) => d.features[1]);\n  const xRange = xValues.length ? getRange(xValues) : { min: -0.1, max: 1.1 };\n  const yRange = yValues.length ? getRange(yValues) : { min: -0.1, max: 1.1 };\n\n  drawAxes(ctx, plotWidth, plotHeight, margin, 'Flavor surprise', 'Texture surprise');\n\n  const gridSteps = 40;\n  for (let gx = 0; gx <= gridSteps; gx += 1) {\n    for (let gy = 0; gy <= gridSteps; gy += 1) {\n      const xVal = xRange.min + (gx / gridSteps) * (xRange.max - xRange.min);\n      const yVal = yRange.min + (gy / gridSteps) * (yRange.max - yRange.min);\n      const prediction = model.predict([xVal, yVal]);\n      const colorValue = Math.round(prediction * 200);\n      ctx.fillStyle = `rgba(${colorValue}, ${220 - colorValue}, 255, 0.4)`;\n      const xPixel = scale(xVal, xRange, { min: margin.left, max: plotWidth - margin.right });\n      const yPixel = scale(yVal, yRange, { min: plotHeight - margin.bottom, max: margin.top });\n      const cellWidth = (plotWidth - margin.left - margin.right) / gridSteps;\n      const cellHeight = (plotHeight - margin.top - margin.bottom) / gridSteps;\n      ctx.fillRect(xPixel - cellWidth / 2, yPixel - cellHeight / 2, cellWidth, cellHeight);\n    }\n  }\n\n  dataset.forEach((point) => {\n    const x = scale(point.features[0], xRange, { min: margin.left, max: plotWidth - margin.right });\n    const y = scale(point.features[1], yRange, { min: plotHeight - margin.bottom, max: margin.top });\n    ctx.fillStyle = point.label === 1 ? '#f97316' : '#7c3aed';\n    ctx.beginPath();\n    ctx.arc(x, y, 7, 0, Math.PI * 2);\n    ctx.fill();\n  });\n}\n\n\n//# sourceURL=webpack://mlalgo/./src/visualization.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;